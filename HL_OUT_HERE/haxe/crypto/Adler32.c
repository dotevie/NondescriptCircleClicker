// Generated by HLC 4.3.1 (HL v5)
#define HLC_BOOT
#include <hlc.h>
#include <haxe/crypto/Adler32.h>
#include <haxe/io/Bytes.h>
int haxe_io_Bytes_get(haxe__io__Bytes,int);
extern hl_type t$haxe_crypto_Adler32;

void haxe_crypto_Adler32_new(haxe__crypto__Adler32 r0) {
	int r1;
	r1 = 1;
	r0->a1 = r1;
	r1 = 0;
	r0->a2 = r1;
	return;
}

void haxe_crypto_Adler32_update(haxe__crypto__Adler32 r0,haxe__io__Bytes r1,int r2,int r3) {
	int r4, r6, r7, r8, r9, r10, r11, r12;
	r4 = r0->a1;
	r6 = r0->a2;
	r7 = r2;
	r8 = r2 + r3;
	label$c21807d_2_4:
	if( r7 >= r8 ) goto label$c21807d_2_19;
	r9 = r7;
	++r7;
	if( r1 == NULL ) hl_null_access();
	r10 = haxe_io_Bytes_get(r1,r9);
	r11 = r4 + r10;
	r12 = 65521;
	r11 = r12 == 0 ? 0 : r11 % r12;
	r4 = r11;
	r11 = r6 + r4;
	r12 = 65521;
	r11 = r12 == 0 ? 0 : r11 % r12;
	r6 = r11;
	goto label$c21807d_2_4;
	label$c21807d_2_19:
	r0->a1 = r4;
	r0->a2 = r6;
	return;
}

bool haxe_crypto_Adler32_equals(haxe__crypto__Adler32 r0,haxe__crypto__Adler32 r1) {
	bool r4;
	int r2, r3;
	if( r1 == NULL ) hl_null_access();
	r2 = r1->a1;
	r3 = r0->a1;
	if( r2 != r3 ) goto label$c21807d_3_11;
	r2 = r1->a2;
	r3 = r0->a2;
	if( r2 == r3 ) goto label$c21807d_3_9;
	r4 = false;
	goto label$c21807d_3_10;
	label$c21807d_3_9:
	r4 = true;
	label$c21807d_3_10:
	return r4;
	label$c21807d_3_11:
	r4 = false;
	return r4;
}

haxe__crypto__Adler32 haxe_crypto_Adler32_read(haxe__io__Input r0) {
	int r3, r4, r5, r6, r7, r8;
	haxe__crypto__Adler32 r1;
	r1 = (haxe__crypto__Adler32)hl_alloc_obj(&t$haxe_crypto_Adler32);
	haxe_crypto_Adler32_new(r1);
	if( r0 == NULL ) hl_null_access();
	r3 = ((int (*)(haxe__io__Input))r0->$type->vobj_proto[0])(r0);
	r4 = ((int (*)(haxe__io__Input))r0->$type->vobj_proto[0])(r0);
	r5 = ((int (*)(haxe__io__Input))r0->$type->vobj_proto[0])(r0);
	r6 = ((int (*)(haxe__io__Input))r0->$type->vobj_proto[0])(r0);
	r8 = 8;
	r7 = r5 << r8;
	r7 = r7 | r6;
	r1->a1 = r7;
	r8 = 8;
	r7 = r3 << r8;
	r7 = r7 | r4;
	r1->a2 = r7;
	return r1;
}

